/*
Web backend for Vikingr

The main api for Vikingr

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AccountsApiService AccountsApi service
type AccountsApiService service

type ApiAddAccountToCompanyRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	account *Account
	identity *string
}

func (r ApiAddAccountToCompanyRequest) Account(account Account) ApiAddAccountToCompanyRequest {
	r.account = &account
	return r
}

func (r ApiAddAccountToCompanyRequest) Identity(identity string) ApiAddAccountToCompanyRequest {
	r.identity = &identity
	return r
}

func (r ApiAddAccountToCompanyRequest) Execute() (*AccountEntity, *http.Response, error) {
	return r.ApiService.AddAccountToCompanyExecute(r)
}

/*
AddAccountToCompany Add Account To Company

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @return ApiAddAccountToCompanyRequest
*/
func (a *AccountsApiService) AddAccountToCompany(ctx context.Context, parentPk string) ApiAddAccountToCompanyRequest {
	return ApiAddAccountToCompanyRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
	}
}

// Execute executes the request
//  @return AccountEntity
func (a *AccountsApiService) AddAccountToCompanyExecute(r ApiAddAccountToCompanyRequest) (*AccountEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.AddAccountToCompany")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.account == nil {
		return localVarReturnValue, nil, reportError("account is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.account
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	identity *string
}

func (r ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest) Identity(identity string) ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest {
	r.identity = &identity
	return r
}

func (r ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostExecute(r)
}

/*
CreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPost Create Account Campaign

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @return ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest
*/
func (a *AccountsApiService) CreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPost(ctx context.Context, parentPk string, entityPk string) ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest {
	return ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AccountsApiService) CreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostExecute(r ApiCreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.CreateAccountCampaignApiCompaniesParentPkAccountsEntityPkCreateCampaignPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}/create-campaign"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	identity *string
}

func (r ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest) Identity(identity string) ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest {
	r.identity = &identity
	return r
}

func (r ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetExecute(r)
}

/*
GetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGet Get Account Exposed Services

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @return ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest
*/
func (a *AccountsApiService) GetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGet(ctx context.Context, parentPk string, entityPk string) ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest {
	return ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
	}
}

// Execute executes the request
//  @return []string
func (a *AccountsApiService) GetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetExecute(r ApiGetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.GetAccountExposedServicesApiCompaniesParentPkAccountsEntityPkServicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}/services"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	identity *string
}

func (r ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest) Identity(identity string) ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest {
	r.identity = &identity
	return r
}

func (r ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest) Execute() (*AccountServicesSummary, *http.Response, error) {
	return r.ApiService.GetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetExecute(r)
}

/*
GetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGet Get Account Exposed Services

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @return ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest
*/
func (a *AccountsApiService) GetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGet(ctx context.Context, parentPk string) ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest {
	return ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
	}
}

// Execute executes the request
//  @return AccountServicesSummary
func (a *AccountsApiService) GetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetExecute(r ApiGetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGetRequest) (*AccountServicesSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountServicesSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.GetAccountExposedServicesApiCompaniesParentPkAccountsServicesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/services-summary"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompanyAccountRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	identity *string
}

func (r ApiGetCompanyAccountRequest) Identity(identity string) ApiGetCompanyAccountRequest {
	r.identity = &identity
	return r
}

func (r ApiGetCompanyAccountRequest) Execute() (*AccountWithAssets, *http.Response, error) {
	return r.ApiService.GetCompanyAccountExecute(r)
}

/*
GetCompanyAccount Get Company Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @return ApiGetCompanyAccountRequest
*/
func (a *AccountsApiService) GetCompanyAccount(ctx context.Context, parentPk string, entityPk string) ApiGetCompanyAccountRequest {
	return ApiGetCompanyAccountRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
	}
}

// Execute executes the request
//  @return AccountWithAssets
func (a *AccountsApiService) GetCompanyAccountExecute(r ApiGetCompanyAccountRequest) (*AccountWithAssets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountWithAssets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.GetCompanyAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCompanyAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	search *string
	presentInService *string
	marker *string
	limit *int32
	identity *string
}

func (r ApiListCompanyAccountsRequest) Search(search string) ApiListCompanyAccountsRequest {
	r.search = &search
	return r
}

func (r ApiListCompanyAccountsRequest) PresentInService(presentInService string) ApiListCompanyAccountsRequest {
	r.presentInService = &presentInService
	return r
}

func (r ApiListCompanyAccountsRequest) Marker(marker string) ApiListCompanyAccountsRequest {
	r.marker = &marker
	return r
}

func (r ApiListCompanyAccountsRequest) Limit(limit int32) ApiListCompanyAccountsRequest {
	r.limit = &limit
	return r
}

func (r ApiListCompanyAccountsRequest) Identity(identity string) ApiListCompanyAccountsRequest {
	r.identity = &identity
	return r
}

func (r ApiListCompanyAccountsRequest) Execute() (*PaginatedEntityCollectionAccountEntity, *http.Response, error) {
	return r.ApiService.ListCompanyAccountsExecute(r)
}

/*
ListCompanyAccounts List Company Accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @return ApiListCompanyAccountsRequest
*/
func (a *AccountsApiService) ListCompanyAccounts(ctx context.Context, parentPk string) ApiListCompanyAccountsRequest {
	return ApiListCompanyAccountsRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
	}
}

// Execute executes the request
//  @return PaginatedEntityCollectionAccountEntity
func (a *AccountsApiService) ListCompanyAccountsExecute(r ApiListCompanyAccountsRequest) (*PaginatedEntityCollectionAccountEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedEntityCollectionAccountEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.ListCompanyAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.presentInService != nil {
		localVarQueryParams.Add("present_in_service", parameterToString(*r.presentInService, ""))
	}
	if r.marker != nil {
		localVarQueryParams.Add("marker", parameterToString(*r.marker, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveCompanyAccountRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	identity *string
}

func (r ApiRemoveCompanyAccountRequest) Identity(identity string) ApiRemoveCompanyAccountRequest {
	r.identity = &identity
	return r
}

func (r ApiRemoveCompanyAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveCompanyAccountExecute(r)
}

/*
RemoveCompanyAccount Remove Company Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @return ApiRemoveCompanyAccountRequest
*/
func (a *AccountsApiService) RemoveCompanyAccount(ctx context.Context, parentPk string, entityPk string) ApiRemoveCompanyAccountRequest {
	return ApiRemoveCompanyAccountRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
	}
}

// Execute executes the request
func (a *AccountsApiService) RemoveCompanyAccountExecute(r ApiRemoveCompanyAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.RemoveCompanyAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	identity *string
}

func (r ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest) Identity(identity string) ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest {
	r.identity = &identity
	return r
}

func (r ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostExecute(r)
}

/*
SendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPost Send Email Verification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @return ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest
*/
func (a *AccountsApiService) SendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPost(ctx context.Context, parentPk string, entityPk string) ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest {
	return ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AccountsApiService) SendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostExecute(r ApiSendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.SendEmailVerificationApiCompaniesParentPkAccountsEntityPkVerifyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCompanyAccountRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	account *Account
	identity *string
}

func (r ApiUpdateCompanyAccountRequest) Account(account Account) ApiUpdateCompanyAccountRequest {
	r.account = &account
	return r
}

func (r ApiUpdateCompanyAccountRequest) Identity(identity string) ApiUpdateCompanyAccountRequest {
	r.identity = &identity
	return r
}

func (r ApiUpdateCompanyAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCompanyAccountExecute(r)
}

/*
UpdateCompanyAccount Update Company Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @return ApiUpdateCompanyAccountRequest
*/
func (a *AccountsApiService) UpdateCompanyAccount(ctx context.Context, parentPk string, entityPk string) ApiUpdateCompanyAccountRequest {
	return ApiUpdateCompanyAccountRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
	}
}

// Execute executes the request
func (a *AccountsApiService) UpdateCompanyAccountExecute(r ApiUpdateCompanyAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.UpdateCompanyAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.account == nil {
		return nil, reportError("account is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.account
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	accountList **os.File
	identity *string
}

func (r ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest) AccountList(accountList *os.File) ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest {
	r.accountList = &accountList
	return r
}

func (r ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest) Identity(identity string) ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest {
	r.identity = &identity
	return r
}

func (r ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest) Execute() (*UploadResponse, *http.Response, error) {
	return r.ApiService.UploadAccountListApiCompaniesParentPkAccountsUploadPostExecute(r)
}

/*
UploadAccountListApiCompaniesParentPkAccountsUploadPost Upload Account List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @return ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest
*/
func (a *AccountsApiService) UploadAccountListApiCompaniesParentPkAccountsUploadPost(ctx context.Context, parentPk string) ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest {
	return ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
	}
}

// Execute executes the request
//  @return UploadResponse
func (a *AccountsApiService) UploadAccountListApiCompaniesParentPkAccountsUploadPostExecute(r ApiUploadAccountListApiCompaniesParentPkAccountsUploadPostRequest) (*UploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.UploadAccountListApiCompaniesParentPkAccountsUploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountList == nil {
		return localVarReturnValue, nil, reportError("accountList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var accountListLocalVarFormFileName string
	var accountListLocalVarFileName     string
	var accountListLocalVarFileBytes    []byte

	accountListLocalVarFormFileName = "account_list"

	accountListLocalVarFile := *r.accountList
	if accountListLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(accountListLocalVarFile)
		accountListLocalVarFileBytes = fbs
		accountListLocalVarFileName = accountListLocalVarFile.Name()
		accountListLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: accountListLocalVarFileBytes, fileName: accountListLocalVarFileName, formFileName: accountListLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetRequest struct {
	ctx context.Context
	ApiService *AccountsApiService
	parentPk string
	entityPk string
	verificationSecret string
}

func (r ApiVerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.VerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetExecute(r)
}

/*
VerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGet Verify Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentPk
 @param entityPk
 @param verificationSecret
 @return ApiVerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetRequest
*/
func (a *AccountsApiService) VerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGet(ctx context.Context, parentPk string, entityPk string, verificationSecret string) ApiVerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetRequest {
	return ApiVerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetRequest{
		ApiService: a,
		ctx: ctx,
		parentPk: parentPk,
		entityPk: entityPk,
		verificationSecret: verificationSecret,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AccountsApiService) VerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetExecute(r ApiVerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.VerifyAccountApiCompaniesParentPkAccountsEntityPkVerifyVerificationSecretGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/companies/{parent_pk}/accounts/{entity_pk}/verify/{verification_secret}"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_pk"+"}", url.PathEscape(parameterToString(r.parentPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entity_pk"+"}", url.PathEscape(parameterToString(r.entityPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"verification_secret"+"}", url.PathEscape(parameterToString(r.verificationSecret, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
